"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.loadAndRepeat = exports.getLoaderConfig = exports.load = exports.isRemoteConfig = exports.isLocalConfig = exports.loadRemoteSkipAuth = exports.loadRemote = exports.loadLocal = exports.loadVcapServices = void 0;
var console = require("console");
var fs = require("fs");
var yaml = require("js-yaml");
var path = require("path");
var util = require("util");
var node_fetch_1 = require("node-fetch");
var url_1 = require("url");
var EnvYamlType = new yaml.Type("!env", {
    kind: "scalar",
    construct: function (string) {
        return process.env[string];
    },
});
var SchemaWithEnv = yaml.Schema.create([EnvYamlType]);
/**
 * loads and parses VCAP_SERVICES json from process.env if possible, otherwise falls back to local vcap_servcies json file
 *
 * @export
 * @param {(string | undefined)} vcap_services contents of process.env.vcap_services
 * @param {string} [vcaplocalPath="./vcap_services.json"] local vcap_servcies file path
 * @returns
 */
function loadVcapServices(vcap_services, vcaplocalPath) {
    if (vcaplocalPath === void 0) { vcaplocalPath = "./vcap_services.json"; }
    if (vcap_services) {
        return JSON.parse(vcap_services || "") || {};
    }
    else {
        var localPath = path.resolve(process.cwd(), vcaplocalPath);
        return fs.existsSync(localPath)
            ? JSON.parse(fs.readFileSync(localPath, "utf8"))
            : {};
    }
}
exports.loadVcapServices = loadVcapServices;
/**
 * loads config from local yml file based on the path provided
 *
 * @export
 * @param {LocalLoaderConfig} config object containing the path of the local yml file to load
 * @returns {Promise<any>} returns config object parsed from remote yml file
 */
function loadLocal(config) {
    return __awaiter(this, void 0, void 0, function () {
        var ymlString, appConfig;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, util.promisify(fs.readFile)(path.resolve(process.cwd(), config.path), "utf8")];
                case 1:
                    ymlString = _a.sent();
                    appConfig = yaml.safeLoad(ymlString, { schema: SchemaWithEnv });
                    return [2 /*return*/, appConfig];
            }
        });
    });
}
exports.loadLocal = loadLocal;
/**
 * Uses credentials pulled from VCAP_SERVICES to authenticate via OAUTH2 and pulls configuration from bound Spring Cloud Config Server based on app name and profile
 *
 * @export
 * @param {RemoteLoaderConfig} config object specifying connection details of a Spring Cloud Config Server
 * @param {any} [request=fetch] optional request object to use for making calls to config server (defaults to node-fetch)
 * @returns {Promise<any>} returns config object parsed from remote yml file
 */
function loadRemote(config, request) {
    if (request === void 0) { request = node_fetch_1.default; }
    return __awaiter(this, void 0, void 0, function () {
        var appName, profile, uri, access_token_uri, client_id, client_secret, params, response, access_token, ymlString;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    appName = config.appName, profile = config.profile, uri = config.uri, access_token_uri = config.access_token_uri, client_id = config.client_id, client_secret = config.client_secret;
                    params = new url_1.URLSearchParams();
                    params.append("grant_type", "client_credentials");
                    params.append("client_id", client_id);
                    params.append("client_secret", client_secret);
                    return [4 /*yield*/, request(access_token_uri, {
                            method: "POST",
                            body: params,
                        })];
                case 1:
                    response = _a.sent();
                    return [4 /*yield*/, response.json()];
                case 2:
                    access_token = (_a.sent()).access_token;
                    return [4 /*yield*/, request(getYmlUri(uri, appName, profile), {
                            headers: {
                                authorization: "bearer " + access_token,
                            },
                        })];
                case 3:
                    response = _a.sent();
                    return [4 /*yield*/, response.text()];
                case 4:
                    ymlString = _a.sent();
                    return [2 /*return*/, yaml.safeLoad(ymlString)];
            }
        });
    });
}
exports.loadRemote = loadRemote;
/**
 * Pulls configuration from bound Spring Cloud Config Server based on app name and profile
 * This method skips the authentication step
 *
 * @export
 * @param {RemoteSkipAuthLoaderConfig} config object specifying connection details of a Spring Cloud Config Server
 * @param {any} [request=fetch] optional request object to use for making calls to config server (defaults to node-fetch)
 * @returns {Promise<any>} returns config object parsed from remote yml file
 */
function loadRemoteSkipAuth(config, request) {
    if (request === void 0) { request = node_fetch_1.default; }
    return __awaiter(this, void 0, void 0, function () {
        var appName, profile, uri, response, ymlString;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    appName = config.appName, profile = config.profile, uri = config.uri;
                    return [4 /*yield*/, request(getYmlUri(uri, appName, profile))];
                case 1:
                    response = _a.sent();
                    return [4 /*yield*/, response.text()];
                case 2:
                    ymlString = _a.sent();
                    return [2 /*return*/, yaml.safeLoad(ymlString)];
            }
        });
    });
}
exports.loadRemoteSkipAuth = loadRemoteSkipAuth;
function getYmlUri(uri, appName, profile) {
    return uri + "/" + appName + "-" + profile + ".yml";
}
/**
 * Tests to see if provided LoaderConfig is a LocalLoaderConfig
 *
 * @export
 * @param {LoaderConfig} config
 * @returns {config is LocalLoaderConfig}
 */
function isLocalConfig(config) {
    return config.path !== undefined;
}
exports.isLocalConfig = isLocalConfig;
/**
 * Tests to see if provided LoaderConfig is a RemoteLoaderConfig
 *
 * @export
 * @param {LoaderConfig} config
 * @returns {config is RemoteLoaderConfig}
 */
function isRemoteConfig(config) {
    return (config.access_token_uri !== undefined &&
        config.client_id !== undefined &&
        config.client_secret !== undefined);
}
exports.isRemoteConfig = isRemoteConfig;
/**
 * Loads configuration from either remote or local location based on provided configuration object
 *
 * @export
 * @param {LoaderConfig} config Object containing parameters to use for loading configuration
 * @param {any} [loadLocalFunc=loadLocal] function responsible for loading local yml file
 * @param {any} [loadRemoteFunc=loadRemote] function responsible for loading config from Spring Cloud Config Server
 * @param {any} [loadRemoteSkipAuthFunc=loadRemoteSkipAuth] function responsible for loading config from
 * Spring Cloud Config Server skipping the authorization step
 * @returns {Promise<any>} returns loaded configuration object
 */
function load(config, params, loadLocalFunc, loadRemoteFunc, loadRemoteSkipAuthFunc) {
    if (loadLocalFunc === void 0) { loadLocalFunc = loadLocal; }
    if (loadRemoteFunc === void 0) { loadRemoteFunc = loadRemote; }
    if (loadRemoteSkipAuthFunc === void 0) { loadRemoteSkipAuthFunc = loadRemoteSkipAuth; }
    return __awaiter(this, void 0, void 0, function () {
        var appConfig, appName, configServerName, configLocation, profile, logProperties;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!isLocalConfig(config)) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadLocalFunc(config)];
                case 1:
                    appConfig = _a.sent();
                    return [3 /*break*/, 6];
                case 2:
                    if (!isRemoteConfig(config)) return [3 /*break*/, 4];
                    return [4 /*yield*/, loadRemoteFunc(config)];
                case 3:
                    appConfig = _a.sent();
                    return [3 /*break*/, 6];
                case 4: return [4 /*yield*/, loadRemoteSkipAuthFunc(config)];
                case 5:
                    appConfig = _a.sent();
                    _a.label = 6;
                case 6:
                    appName = params.appName, configServerName = params.configServerName, configLocation = params.configLocation, profile = params.profile, logProperties = params.logProperties;
                    console.debug("Settings loaded from " + configLocation + " " + configServerName + " for " + appName + "-" + profile);
                    if (logProperties) {
                        console.debug("--------------------------------");
                        console.debug(JSON.stringify(appConfig, null, 2));
                    }
                    return [2 /*return*/, appConfig];
            }
        });
    });
}
exports.load = load;
var configServerServiceNameValues = ["p-config-server", "p.config-server"];
/**
 * Generated appropriate loader config file based on whether configuration is to be loaded locally or remotely
 *
 * @export
 * @param {ConfigParams} params contains parameters used to load correct configuration
 * @returns {LoaderConfig} either a LocalLoaderConfig or a RemoteLoaderConfig
 */
function getLoaderConfig(params, loadVcapServicesFunc) {
    if (loadVcapServicesFunc === void 0) { loadVcapServicesFunc = loadVcapServices; }
    var appName = params.appName, profile = params.profile, configServerName = params.configServerName, configLocation = params.configLocation;
    var loaderConfig;
    if (configLocation === "remote") {
        var vcap_services_1 = loadVcapServicesFunc(process.env.VCAP_SERVICES);
        var configServerServiceName = configServerServiceNameValues.find(function (configServerServiceName) {
            return vcap_services_1.hasOwnProperty(configServerServiceName);
        });
        if (!configServerServiceName) {
            throw new Error("Either " + configServerServiceNameValues.join(" or ") + " must be defined on VCAP_SERVICES");
        }
        var credentials = vcap_services_1["" + configServerServiceName].find(function (cfg) { return cfg.name === configServerName; }).credentials;
        loaderConfig = __assign({ appName: appName,
            profile: profile }, credentials);
    }
    else if (configLocation == "remoteSkipAuth") {
        var uri = process.env.CONFIG_SERVER_URI_WHEN_SKIP_AUTH;
        loaderConfig = {
            appName: appName,
            profile: profile,
            uri: uri,
        };
    }
    else {
        loaderConfig = {
            path: "./" + configServerName + "/" + appName + "-" + profile + ".yml",
        };
    }
    return loaderConfig;
}
exports.getLoaderConfig = getLoaderConfig;
/**
 * Wraps config load call inside optional setInterval for auto-updating
 * @param config
 * @param params
 * @param updateFunc
 * @param loadLocalFunc
 * @param loadRemoteFunc
 */
function loadAndRepeat(config, params, updateFunc, loadLocalFunc, loadRemoteFunc) {
    if (loadLocalFunc === void 0) { loadLocalFunc = loadLocal; }
    if (loadRemoteFunc === void 0) { loadRemoteFunc = loadRemote; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, interval;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = updateFunc;
                    return [4 /*yield*/, load(config, params, loadLocalFunc, loadRemoteFunc)];
                case 1:
                    _a.apply(void 0, [_b.sent()]);
                    interval = params.interval;
                    if (interval) {
                        console.debug("set to auto-refresh config with interval of " + interval + " seconds");
                        setInterval(function () { return __awaiter(_this, void 0, void 0, function () {
                            var _a, err_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 2, , 3]);
                                        console.debug("auto-refreshing config after waiting " + interval + " seconds");
                                        _a = updateFunc;
                                        return [4 /*yield*/, load(config, params, loadLocalFunc, loadRemoteFunc)];
                                    case 1:
                                        _a.apply(void 0, [_b.sent()]);
                                        return [3 /*break*/, 3];
                                    case 2:
                                        err_1 = _b.sent();
                                        console.debug("Problem encountered while refreshing config; using previous config: " + err_1);
                                        return [3 /*break*/, 3];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); }, interval * 1000);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.loadAndRepeat = loadAndRepeat;
/**
 * Config class contains the global app configuration once loaded
 *
 * @export
 * @class Config
 */
var Config = /** @class */ (function () {
    function Config() {
    }
    /**
     * loads the app config *must be called during the start of the application*
     *
     * @static
     * @param {ConfigParams} params
     * @returns {Promise<void>}
     * @memberof Config
     */
    Config.load = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var config;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        config = getLoaderConfig(params);
                        return [4 /*yield*/, loadAndRepeat(config, params, function (loadedConfig) {
                                _this.current = loadedConfig;
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return Config;
}());
exports.Config = Config;
